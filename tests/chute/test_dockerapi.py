from paradrop.shared import dockerapi
from mock import patch, MagicMock

HOST_CONFIG1 = {'RestartPolicy': {'MaximumRetryCount': 5, 'Name': 'on-failure'}, 'NetworkMode': 'bridge', 'LxcConf': [], 'CapAdd': ['NET_ADMIN']}
HOST_CONFIG2 = {'RestartPolicy': {'MaximumRetryCount': 5, 'Name': 'on-failure'}, 'NetworkMode': 'bridge', 'PortBindings': {'80/tcp': [{'HostPort': '9000', 'HostIp': ''}]}, 'LxcConf': [], 'Dns': ['0.0.0.0', '8.8.8.8'], 'CapAdd': ['NET_ADMIN']}

DOCKER_CONF = """
# Docker systemd configuration
#
# This configuration file was automatically generated by Paradrop.  Any changes
# will be overwritten on startup.

# Tell docker not to start containers automatically on startup.
DOCKER_OPTIONS="--restart=false"
"""


def fake_update():
    class Object(object):
        pass

    update = Object()
    update.new = Object()
    return update


def test_build_host_config():
    """
    Test that the build_host_config function does it's job.
    """
    # Check that an empty host_config gives us certain default settings
    u = fake_update()
    res = dockerapi.build_host_config(u)
    print '\nExpected: ', HOST_CONFIG1, '\nResult: ', res, '\n'
    assert res == HOST_CONFIG1

    # Check that passing things through host_config works
    u = MagicMock()
    u.new.host_config = {'port_bindings': {80: 9000}, 'dns': ['0.0.0.0', '8.8.8.8']}
    res = dockerapi.build_host_config(u)
    print '\nExpected: ', HOST_CONFIG2, '\nResult: ', res, '\n'
    assert res == HOST_CONFIG2


@patch('paradrop.shared.dockerapi.log')
@patch('docker.Client')
def test_failAndCleanUpDocker(mockDocker, mockOutput):
    """
    Test that the failure and clean up function does it's job.
    """
    client = MagicMock()
    mockDocker.return_value = client
    # call clean up with empty sets, matching sets, and different sets for valid and current images and test
    for pair in [[[], []], [[1, 2, 3], [1, 2, 3]], [[{'Id': 1}, {'Id': 2}, {'Id': 3}], [{'Id': 1}, {'Id': 2}, {'Id': 3}, {'Id': 4}, {'Id': 5}]]]:
        # fake that docker is returning the second list in the pair as the current images and containers on the device
        client.containers.return_value = pair[1]
        client.images.return_value = pair[1]
        try:
            dockerapi.failAndCleanUpDocker(pair[0], pair[0])
        except Exception as e:
            # we should always see this exception
            assert e.message == 'Building or starting of docker image failed check your Dockerfile for errors.'
        mockDocker.assert_called_with(base_url='unix://var/run/docker.sock', version='auto')
        client.containers.assert_called_once_with(quiet=True, all=True)
        client.images.assert_called_once_with(quiet=True, all=False)
        if pair[1] == pair[0]:
            assert client.remove_image.call_count == 0
            assert client.remove_container.call_count == 0
        else:
            img_expected = "[call(image={'Id': 4}), call(image={'Id': 5})]"
            cntr_expected = "[call(container=4), call(container=5)]"
            assert str(client.remove_image.call_args_list) == img_expected
            assert str(client.remove_container.call_args_list) == cntr_expected
            assert client.remove_image.call_count == 2
            assert client.remove_container.call_count == 2
        client.reset_mock()


@patch('paradrop.shared.dockerapi.setup_net_interfaces')
@patch('paradrop.shared.dockerapi.log')
@patch('docker.Client')
def test_restartChute(mockDocker, mockOutput, mockInterfaces):
    """
    Test that the restartChute function does it's job.
    """
    update = MagicMock()
    update.name = 'test'
    client = MagicMock()
    mockDocker.return_value = client
    dockerapi.restartChute(update)
    mockDocker.assert_called_once_with(base_url='unix://var/run/docker.sock', version='auto')
    mockInterfaces.assert_called_once_with(update)
    client.start.assert_called_once_with(container=update.name)


@patch('paradrop.shared.dockerapi.log')
@patch('docker.Client')
def test_stopChute(mockDocker, mockOutput):
    """
    Test that the stopChute function does it's job.
    """
    update = MagicMock()
    update.name = 'test'
    client = MagicMock()
    mockDocker.return_value = client
    dockerapi.stopChute(update)
    mockDocker.assert_called_once_with(base_url='unix://var/run/docker.sock', version='auto')
    client.stop.assert_called_once_with(container=update.name)


@patch('paradrop.shared.dockerapi.log')
@patch('docker.Client')
def test_removeChute(mockDocker, mockOutput):
    """
    Test that the stopChute function does it's job.
    """
    update = MagicMock()
    update.name = 'test'
    client = MagicMock()
    mockDocker.return_value = client
    dockerapi.removeChute(update)
    mockDocker.assert_called_once_with(base_url='unix://var/run/docker.sock', version='auto')
    client.remove_container.assert_called_once_with(container=update.name, force=True)
    client.remove_image.assert_called_once_with(image='test:latest')
    assert update.complete.call_count == 0
    client.reset_mock()
    client.remove_container.side_effect = Exception('Test')
    try:
        dockerapi.removeChute(update)
    except Exception as e:
        assert e.message == 'Test'
    client.remove_container.assert_called_once_with(container=update.name, force=True)
    assert update.complete.call_count == 1


@patch('paradrop.shared.dockerapi.failAndCleanUpDocker')
@patch('paradrop.shared.dockerapi.build_host_config')
@patch('paradrop.shared.dockerapi.setup_net_interfaces')
@patch('paradrop.shared.dockerapi.log')
@patch('docker.Client')
def test_startChute(mockDocker, mockOutput, mockInterfaces, mockConfig, mockFail):
    """
    Test that the startChute function does it's job.
    """
    # Test successful start attempt
    mockConfig.return_value = 'ConfigDict'
    update = MagicMock()
    update.name = 'test'
    update.dockerfile = 'Dockerfile'
    client = MagicMock()
    client.images.return_value = 'images'
    client.containers.return_value = 'containers'
    client.build.return_value = ['{"stream": "test"}', '{"value": {"test": "testing"}}', '{"tests": "stuff"}']
    client.create_container.return_value = {'Id': 123}
    mockDocker.return_value = client
    dockerapi.startChute(update)
    mockConfig.assert_called_once_with(update)
    mockDocker.assert_called_once_with(base_url='unix://var/run/docker.sock', version='auto')
    client.images.assert_called_once_with(quiet=True, all=False)
    client.containers.assert_called_once_with(quiet=True, all=True)
    client.build.assert_called_once_with(rm=True, tag='test:latest', fileobj='Dockerfile')
    client.create_container.assert_called_once_with(image='test:latest', name='test', host_config='ConfigDict')
    client.start.assert_called_once_with(123)
    assert update.pkg.request.write.call_count == 2
    mockInterfaces.assert_called_once_with(update)

    # Test failed build
    client.build.return_value = ['{"errorDetail": "Errors"}']
    dockerapi.startChute(update)
    mockFail.assert_called_once_with('images', 'containers')

    # Test when create or start throws exceptions
    mockFail.reset_mock()
    client.build.return_value = ['{"stream": "test"}', '{"value": {"test": "testing"}}', '{"tests": "stuff"}']
    client.create_container.side_effect = Exception('create container exception')
    dockerapi.startChute(update)
    mockFail.assert_called_once_with('images', 'containers')
    mockFail.reset_mock()
    client.start.side_effect = Exception('start exception')
    dockerapi.startChute(update)
    mockFail.assert_called_once_with('images', 'containers')


@patch('paradrop.shared.dockerapi.os')
@patch('paradrop.shared.dockerapi.subprocess')
@patch('paradrop.shared.dockerapi.log')
def test_setup_net_interfaces(mockOutput, mockSubproc, mockOS):
    """
    Test that the setup_net_interfaces function does it's job.
    """
    # Test successful setup
    update = MagicMock()
    update.name = 'testing'
    update.new.getCache.return_value = [{'netType': 'wifi', 'ipaddrWithPrefix': '0.0.0.0/24', 'internalIntf': 'Inside', 'externalIntf': 'Outside'}, {'netType': 'lan'}]
    mockOS.environ.get.return_value = ""
    proc = MagicMock()
    mockSubproc.Popen.return_value = proc
    mockSubproc.PIPE = 'piping'
    proc.stdout = ['test1', 'test2']
    proc.stderr = ['error']
    dockerapi.setup_net_interfaces(update)
    mockSubproc.Popen.assert_called_once_with(['/apps/paradrop/current/bin/pipework', 'Outside', '-i', 'Inside', update.name, '0.0.0.0/24'],
                                              stdout=mockSubproc.PIPE, stderr=mockSubproc.PIPE, env={"PATH": ":/apps/bin"})

    # Test subprocess throwing an exception
    mockSubproc.Popen.side_effect = OSError('BAD!')
    try:
        dockerapi.setup_net_interfaces(update)
    except OSError as e:
        assert e.message == 'BAD!'


@patch('__builtin__.open')
@patch('paradrop.shared.dockerapi.os')
@patch('paradrop.shared.dockerapi.log')
def test_writeDockerConfig(mockOutput, mockOS, mock_open):
    """
    Test that the writeDockerConfig function does it's job.
    """
    fd = MagicMock()
    mock_open.return_value = fd
    # Test we get a warning and nothing else if path doesn't exist
    mockOS.path.exists.return_value = False
    dockerapi.writeDockerConfig()
    assert not mock_open.called
    assert len(mockOS.method_calls) == 1

    # Test that it writes if we find path
    mockOS.path.exists.side_effect = [True, False, True]
    mockOS.listdir.return_value = ['/root', '/var']
    dockerapi.writeDockerConfig()
    assert mock_open.call_count == 1
    file_handle = mock_open.return_value.__enter__.return_value
    file_handle.write.assert_called_once_with(DOCKER_CONF)

    # Test that we handle an excpetion when opening
    mockOS.path.exists.side_effect = None
    mockOS.path.exists.return_value = True
    mockOS.listdir.return_value = ['/root']
    mock_open.side_effect = Exception('Blammo!')
    dockerapi.writeDockerConfig()
    assert mock_open.call_count == 2
